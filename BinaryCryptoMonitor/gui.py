# mockGUI

from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *

import threading
from PyQtThreads import StartMonThread, KillProcThread

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
plt.rcParams.update({'font.size': 16})

import numpy
from functools import partial
from generalMonitoring import Whitelist


class GUI:
    def __init__(self, mainProgram):
        self.app = QApplication([])
        self.window = QWidget()
        self.layout = QVBoxLayout()
        self.window.setWindowTitle("DetectCryptoMining")
        self.mainProg = mainProgram
        self.threadpool = QThreadPool()
        self.procName = None

        self.windowHeight = 1600
        self.windowWidth = 2000


        self.screen = self.app.primaryScreen()
        screenDimensions = self.screen.availableGeometry()

        self.centeringWidth = (screenDimensions.width() / 2) - (self.windowWidth/2)
        self.centeringHeight = (screenDimensions.height()/2) - (self.windowHeight/2)


        self.window.setGeometry((screenDimensions.width() / 2 - 550), (screenDimensions.height() / 2 - 700), self.windowWidth, self.windowHeight)

        self.titleLabel = QLabel("DetectCryptoMining\n")
        self.titleLabel.setAlignment(Qt.AlignCenter)
        self.roundTableTitle = QLabel("Most recent possible mining detections:")
        self.table = QTableWidget()
        self.miningTableTitle = QLabel("Potential mining processes:")
        self.miningProTable = QTableWidget()

        self.startMonBtn = QPushButton('Start Monitoring')
        self.stopMonButton = QPushButton('Stop Monitoring')
        self.stopMonButton.setCheckable(True)
        self.startMonBtn.clicked.connect(self.startMonitoring)

        self.killBtn = QPushButton("kill")

        self.modWhitelistBtn = QPushButton("Modify Process Whitelist")
        self.modWhitelistBtn.clicked.connect(self.modWhitelist)

        self.figure = plt.figure()
        self.canvas = FigureCanvas(self.figure)
        self.toolbar = NavigationToolbar(self.canvas, self.window)

    # Adds all widgets to the windows layout and start the GUI's execution.
    def mainGUI(self):
        self.layout.addWidget(self.titleLabel)
        self.layout.addWidget(self.toolbar)
        self.layout.addWidget(self.canvas)
        self.layout.addWidget(self.roundTableTitle)
        self.layout.addWidget(self.table)
        self.layout.addWidget(self.miningTableTitle)
        self.layout.addWidget(self.miningProTable)
        self.layout.addWidget(self.modWhitelistBtn)
        self.layout.addWidget(self.startMonBtn)
        self.layout.addWidget(self.stopMonButton)
        self.window.setLayout(self.layout)

        self.window.show()
        self.app.exec_()

    #Starts the monitoring and detection process in a seperate pyqt thread to
    #prevent the gui from freezing.
    def startMonitoring(self):
        if self.stopMonButton.isChecked():
            self.stopMonButton.toggle()
        monThread = StartMonThread(self.mainProg)
        # Connects updateGUI signal from main detection thread to slot updateGUI
        #function within GUI thread. Enables interthread communication of data.
        monThread.signals.updateGUI.connect(self.updateGUI)
        self.threadpool.start(monThread)

    # Checks to see if the user wants to stop the monitoring for
    # crypto-mining activity.
    # Returns: Boolean. True if stop monitoring button has been pressed or
    # otherwise false.
    def checkStop(self):
        QCoreApplication.processEvents()
        if self.stopMonButton.isChecked():
            return True
        else:
            return False

    def toggleStopButton(self):
        self.stopMonButton.toggle()

    def modWhitelist(self):
        wl = Whitelist()
        wl.manuallyModify()
        pass

    # Updates the GUI's tables and graph with new detection data.
    def updateGUI(self, rulesMetDict, detectionHistory):
        self.createPrevDetectionTable(rulesMetDict)
        self.createMiningProcessTable(detectionHistory)
        self.plotDetectionGraph(detectionHistory)

    # Creates tables containing most recent detection data including:
    # the responsible process, and the rules it met.
    def createPrevDetectionTable(self, rulesMetDict):
        self.table.setRowCount(0)
        numSuspectProc = len(rulesMetDict)
        self.table.setRowCount(numSuspectProc + 1)
        self.table.setColumnCount(2)

        self.table.setItem(0, 0, QTableWidgetItem("Process"))
        self.table.setItem(0, 1, QTableWidgetItem("Most recent rules met"))

        self.table.setColumnWidth(1, 500)
        self.table.verticalHeader().setVisible(False)
        self.table.horizontalHeader().setVisible(False)
        self.table.setColumnWidth(1, 350)
        self.table.setRowHeight(1, 120)

        currentRow = 1
        for key in rulesMetDict:
            ruleString = ''
            rulesListLen = len(rulesMetDict[key])
            index = 1

            for rule in rulesMetDict[key]:
                if index != rulesListLen:
                    ruleString += rule + ",\n "
                    index += 1
                else:
                    ruleString += rule

            self.table.setItem(currentRow, 0, QTableWidgetItem(key))
            self.table.setItem(currentRow, 1, QTableWidgetItem(ruleString))
            currentRow += 1

    # Creates a table containing all detection cases information including:
    # process, rules met, the number of times each rules has been met, a button
    # to kill the suspicous process.
    def createMiningProcessTable(self, detectionHistory):
        self.miningProTable.setRowCount(0)
        historyLen = len(detectionHistory)
        btn = None


        self.miningProTable.setRowCount(historyLen + 1)
        self.miningProTable.setColumnCount(3)
        self.miningProTable.verticalHeader().setVisible(False)
        self.miningProTable.horizontalHeader().setVisible(False)

        self.miningProTable.setItem(0, 0, QTableWidgetItem("Process"))
        self.miningProTable.setItem(0, 1, QTableWidgetItem("Total Rules Met"))
        self.miningProTable.setItem(0, 2, QTableWidgetItem("Kill Associated Processes?"))


        currentRow = 1
        dictionaryIndex = 0
        keys = list(detectionHistory.keys())

        while dictionaryIndex != historyLen:
            ruleCountString = ''
            key = keys[dictionaryIndex]
            ruleLen = len(detectionHistory[key])
            dictionaryIndex +=1
            index = 1

            for dict in detectionHistory[key]:
                    ruleCountString += dict + ": " + str(detectionHistory[key][dict]) + "x\n"
            self.killBtn = QPushButton("Kill "+key)
            self.killBtn.clicked.connect(partial(self.killProcess, key))

            self.miningProTable.setItem(currentRow, 0, QTableWidgetItem(key))
            self.miningProTable.setItem(currentRow, 1, QTableWidgetItem(ruleCountString))
            self.miningProTable.setRowHeight(currentRow, 120)
            self.miningProTable.setCellWidget(currentRow, 2, self.killBtn)
            currentRow += 1

        self.miningProTable.setColumnWidth(1, 350)
        self.miningProTable.setRowHeight(1, 120)
        self.miningProTable.setColumnWidth(2, 400)

    def killProcess(self, processName):
        print("kill: " + processName)
        self.procName = processName
        killProcess = KillProcThread(self.procName)
        self.threadpool.start(killProcess)


    # Plots a bar graph containing all detections that have been made for each
    # suspicious process.
    def plotDetectionGraph(self, detectionHistory):
        processesList = list(detectionHistory.keys())
        CPUPercentageCheckData = []
        MemoryUsageCheckData = []

        for proc in detectionHistory:
            try:
                CPUPercentageCheckData.append(detectionHistory[proc]["CPUPercentageCheck"])
            except:
                CPUPercentageCheckData.append(0)
            try:
                MemoryUsageCheckData.append(detectionHistory[proc]["MemoryUsageCheck"])
            except:
                MemoryUsageCheckData.append(0)

        xAxis = numpy.arange(len(CPUPercentageCheckData))
        barWidth = 0.2

        self.figure.clear()

        ax = self.figure.add_subplot(111)
        self.figure.tight_layout()
        ax.grid(axis='y')

        ax.bar(xAxis, CPUPercentageCheckData, width = barWidth, label="CPUPercentageCheck")
        ax.bar(xAxis + barWidth, MemoryUsageCheckData, width = barWidth, label="MemoryUsageCheck")

        ax.set_xticks(xAxis + barWidth*0.5)
        ax.set_xticklabels(processesList)
        ax.set_title("Supicious Processes")
        ax.set_xlabel("Processes")
        ax.set_ylabel("Number of detections")

        ax.legend()

        self.canvas.draw()

# Removes unnecessary icons from the matplotlib toolbar.
class NavigationToolbar(NavigationToolbar2QT):
    toolitems = [t for t in NavigationToolbar2QT.toolitems if t[0] in ('Home', 'Save')]



if __name__ == '__main__':
    gui = GUI()
    gui.mainGUI()
