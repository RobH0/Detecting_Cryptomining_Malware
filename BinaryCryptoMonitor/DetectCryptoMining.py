#DetectCryptoMining
from generalMonitoring import SystemMonitoring
from MatchRules import *
from gui import *
from recorder import *
import threading



#Responsible for Initiating the whole program.
class DetectCryptoMining:
    def __init__(self):
        self.systemMon = SystemMonitoring()
        self.defAndCall = DefineAndCall()
        self.configFile = self.defAndCall.readRuleConfiguration('configuration.yaml')
        self.recorder = Recorder(True)
        self.gui = GUI(self)
        print("Retrieving mining pool IP addresses:")

        # started a new thread for getMiningPoolIPs() since the DNS queries take
        # several seconds to be completed. Threading this function prevents delaying
        # the GUI from being displayed.
        ipThread = threading.Thread(target=self.systemMon.getMiningPoolIPs)
        ipThread.start()
        #self.minerIPs = self.systemMon.getMiningPoolIPs()
        self.gui.mainGUI()



    #Controls the order in which data is monitored and then evaluated.
    def main(self, signals):
        rulesMet = None
        stopButtonStatus = False
        detectionRoundCount = 1

        print(f"\nRule Config: {self.configFile}")
        print(f"Mining Pool IPs: {self.minerIPs}")


        while stopButtonStatus == False:
            cpuMatches = {}
            memoryMatches = {}

            print("\n\n\nDETECTION ROUND: " + str(detectionRoundCount))
            detectionRoundCount+= 1

            # Monitoring phase
            stopButtonStatus = self.gui.checkStop()
            cpuData = self.systemMon.monitorCpuUsage(0.01)
            stopButtonStatus = self.gui.checkStop()
            memoryData = self.systemMon.monitorMemoryUsage()

            stopButtonStatus = self.gui.checkStop()

            # Detection phase
            print("\nRules met by processes: ")
            cpuMatches = self.defAndCall.determineRelevantRule(cpuData, self.configFile)
            memoryMatches = self.defAndCall.determineRelevantRule(memoryData, self.configFile)
            # merging dictionaries that contain the rules met for
            # given processes during the current detection round.
            combinedMatches = self.combineDetectionDicts(cpuMatches, memoryMatches)

            # Visualization phase
            if len(combinedMatches) != None and len(combinedMatches) != 0:
                self.recorder.updateDetectionHistory(combinedMatches)
                detectionHist = self.recorder.readDetectionHistory()
                signals.updateGUI.emit(combinedMatches, detectionHist)
                self.recorder.writeLog(combinedMatches)
            else:
                print("\nNo rules were met at this instance.\n")

            stopButtonStatus = self.gui.checkStop()

        print("\nMonitoring has now been stopped.\n")
        self.gui.toggleStopButton()

    def combineDetectionDicts(self, cpuMatches, memoryMatches):
        combinedMatches = {}
        if bool(cpuMatches):
            for key in cpuMatches:
                combinedMatches[key] = cpuMatches[key]
                if bool(memoryMatches):
                    for key2 in memoryMatches:

                        if key == key2:
                            for item in memoryMatches[key2]:
                                combinedMatches[key].append(item)
                else:
                    combinedMatches = cpuMatches

        else:
            combinedMatches = memoryMatches

        return combinedMatches



if __name__ == '__main__':
    mainProg = DetectCryptoMining()
