# DetectCryptoMining
from generalMonitoring import SystemMonitoring
from MatchRules import *
from gui import *
from recorder import *
import threading


class DetectCryptoMining:
    """Responsible for Initiating the DetectCryptoMining tool."""

    def __init__(self):
        """
        DetectCryptoMining's constructure.
        - Initialises classes within this class.
        - Starts up the GUI.
        - Asks the user whether they want ot update the list of mining pool IP addresses
        """

        self.systemMon = SystemMonitoring()
        self.defAndCall = DefineAndCall()
        self.configFile = self.defAndCall.readRuleConfiguration(
            'configuration.yaml')
        self.recorder = Recorder(True)
        self.gui = GUI(self)
        self.minerIPs = None
        self.askUpdateIPs()
        self.gui.mainGUI()

    # Controls the order in which data is monitored and then evaluated.

    def main(self, signals):
        """
        Controls the order in which data is monitored, evaluated and visualised.

        :param signals: A handle to the :class: `PyQtThreads.Signals` signals object that contains all the PyQt5 signals used by the tool to communicate between threads.
        :type signals: class:`PyQtThreads.Signals`
        """

        rulesMet = None
        stopButtonStatus = False
        detectionRoundCount = 1

        print(f"\nRule Config: {self.configFile}")
        print(f"Mining Pool IPs: {self.minerIPs}")

        while stopButtonStatus == False:
            cpuMatches = {}
            memoryMatches = {}

            print("\n\n\nDETECTION ROUND: " +
                  str(detectionRoundCount))
            detectionRoundCount += 1

            # Monitoring phase
            stopButtonStatus = self.gui.checkStop()
            cpuData = self.systemMon.monitorCpuUsage(0.01)
            stopButtonStatus = self.gui.checkStop()
            memoryData = self.systemMon.monitorMemoryUsage()
            connectionData = self.systemMon.monitorConnection()

            stopButtonStatus = self.gui.checkStop()

            # Detection phase
            print("\nRules met by processes: ")
            cpuMatches = self.defAndCall.determineRelevantRule(
                cpuData, self.configFile)
            memoryMatches = self.defAndCall.determineRelevantRule(
                memoryData, self.configFile)
            connectionMatches = self.defAndCall.determineRelevantRule(
                connectionData, self.configFile)
            # merging dictionaries that contain the rules met for
            # given processes during the current detection round.
            combinedMatches = self.combineDetectionDicts(
                cpuMatches, memoryMatches, connectionMatches)

            # Visualization phase
            if len(combinedMatches) != None and len(combinedMatches) != 0:
                self.recorder.updateDetectionHistory(combinedMatches)
                detectionHist = self.recorder.readDetectionHistory()
                signals.updateGUI.emit(combinedMatches, detectionHist)
                self.recorder.writeLog(combinedMatches)
            else:
                print("\nNo rules were met at this instance.\n")

            stopButtonStatus = self.gui.checkStop()

        print("\nMonitoring has now been stopped.\n")
        self.gui.toggleStopButton()

    # Combines all three detection dictionaries into one.
    def combineDetectionDicts(self, cpuMatches, memoryMatches, connectionMatches):
        """
        Combines all three detection dictionaries into one.

        :param cpuMatches: A dictionary that contains processes and detection rules met by cpu monitoring data collected this monitoring/detection round.
        :type cpuMatches: dict
        :param memoryMatches: A dictionary that contains processes and detection rules met by memory monitoring data collected this monitoring/detection round.
        :type memoryMatches: dict
        :param connectionMatches: A dictionary that contains processes and detection rules met by TCP connection monitoring data collected this monitoring/detection round.
        :type connectionMatches: dict

        :return: A dictionary containing all processes and the detection rules they met compiled from all types of monitoring data.
        :rtype: dict
        """

        combinedMatches = {}
        if bool(cpuMatches):
            for key in cpuMatches:
                combinedMatches[key] = cpuMatches[key]
                if bool(memoryMatches):
                    for key2 in memoryMatches:
                        if key == key2:
                            for item in memoryMatches[key2]:
                                combinedMatches[key].append(item)
                        elif key != key2 and key2 not in cpuMatches:
                            combinedMatches[key2] = memoryMatches[key2]
                else:
                    combinedMatches = cpuMatches
        else:
            combinedMatches = memoryMatches

        if bool(connectionMatches):
            for key in connectionMatches:
                if key in combinedMatches:
                    for item in connectionMatches[key]:
                        combinedMatches[key].append(item)
                elif key not in combinedMatches:
                    combinedMatches[key] = connectionMatches[key]

        return combinedMatches

    # .
    #
    def askUpdateIPs(self):
        """
        Asks the user if they want to update the mining Pool IP address list.
        If yes the IP list is updated. If no the list stored in the poolIPs.pkl file is used.
        """

        print("Would you like to update mining pool IPs for improved mining detection?")
        userInput = input("Enter y or n: ")

        incorrectInput = True

        while incorrectInput == True:
            if userInput.lower() == "y" or userInput.lower() == "yes":
                print("Updating mining pool IP addresses:")
                incorrectInput = False
                self.minerIPs = self.systemMon.getMiningPoolIPs()

            elif userInput.lower() == "n" or userInput.lower() == "no":
                print(
                    "Not updating. The mining pool IP addresses already stored will be used.")
                self.minerIPs = self.recorder.readPoolIPs()
                incorrectInput = False
            else:
                print("Invalid input!")
                userInput = input("Enter y or n: ")


if __name__ == '__main__':
    mainProg = DetectCryptoMining()
