# mockGUI

from PyQt5.QtWidgets import *
from PyQt5.QtCore import *
from PyQt5.QtGui import *

import threading
from PyQtThreads import StartMonThread

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT
from matplotlib.figure import Figure
import matplotlib.pyplot as plt
plt.rcParams.update({'font.size': 16})

import numpy


class GUI2:
    def __init__(self, mainProgram):
        self.app = QApplication([])
        self.window = QWidget()
        self.layout = QVBoxLayout()
        self.window.setWindowTitle("DetectCryptoMining")
        self.mainProg = mainProgram
        self.threadpool = QThreadPool()

        self.windowHeight = 1600
        self.windowWidth = 2000


        self.screen = self.app.primaryScreen()
        screenDimensions = self.screen.availableGeometry()

        self.centeringWidth = (screenDimensions.width() / 2) - (self.windowWidth/2)
        self.centeringHeight = (screenDimensions.height()/2) - (self.windowHeight/2)


        self.window.setGeometry((screenDimensions.width() / 2 - 550), (screenDimensions.height() / 2 - 700), self.windowWidth, self.windowHeight)

        self.titleLabel = QLabel("DetectCryptoMining\n")
        self.titleLabel.setAlignment(Qt.AlignCenter)
        self.roundTableTitle = QLabel("Most recent possible mining detections:")
        self.table = QTableWidget()
        self.miningTableTitle = QLabel("Potential mining processes:")
        self.miningProTable = QTableWidget()

        self.startMonBtn = QPushButton('Start Monitoring')
        self.stopMonButton = QPushButton('Stop Monitoring')
        self.stopMonButton.setCheckable(True)
        self.startMonBtn.clicked.connect(self.startMonitoring)

        self.killBtn = QPushButton("kill")

        self.figure = plt.figure()
        self.canvas = FigureCanvas(self.figure)
        self.toolbar = NavigationToolbar(self.canvas, self.window)

    def mainGUI(self):

        #self.createPrevDetectionTable()
        #self.createMiningProcessTable()
        #self.plotDetectionGraph()
        self.layout.addWidget(self.titleLabel)


        self.layout.addWidget(self.toolbar)
        self.layout.addWidget(self.canvas)
        self.layout.addWidget(self.roundTableTitle)
        self.layout.addWidget(self.table)
        self.layout.addWidget(self.miningTableTitle)
        self.layout.addWidget(self.miningProTable)
        self.layout.addWidget(self.startMonBtn)
        self.layout.addWidget(self.stopMonButton)
        self.window.setLayout(self.layout)

        self.window.show()
        self.app.exec_()

    #Starts the monitoring and detection process in a seperate pyqt thread to
    #prevent the gui from freezing.
    def startMonitoring(self):
        if self.stopMonButton.isChecked():
            self.stopMonButton.toggle()
        monThread = StartMonThread(self.mainProg)
        self.threadpool.start(monThread)

    #checks to see if the user wants to stop the monitoring for crypto-mining activity
    def checkStop(self):
        QCoreApplication.processEvents()
        if self.stopMonButton.isChecked():
            return True
        else:
            return False

    def toggleStopButton(self):
        self.stopMonButton.toggle()

    def updateTables(self, rulesMetDict, detectionHistory):
        self.createPrevDetectionTable(rulesMetDict)
        self.createMiningProcessTable(detectionHistory)
        self.plotDetectionGraph(detectionHistory)

    def createPrevDetectionTable(self, rulesMetDict):
        self.table.setRowCount(0)
        numSuspectProc = len(rulesMetDict)
        self.table.setRowCount(numSuspectProc + 1)
        self.table.setColumnCount(2)

        self.table.setItem(0, 0, QTableWidgetItem("Process"))
        self.table.setItem(0, 1, QTableWidgetItem("Most recent rules met"))

        self.table.setColumnWidth(1, 500)
        self.table.verticalHeader().setVisible(False)
        self.table.horizontalHeader().setVisible(False)
        self.table.setColumnWidth(1, 350)
        self.table.setRowHeight(1, 120)

        currentRow = 1
        for key in rulesMetDict:
            print(f"key: {key}")
            ruleString = ''
            rulesListLen = len(rulesMetDict[key])
            index = 1

            for rule in rulesMetDict[key]:
                if index != rulesListLen:
                    ruleString += rule + ",\n "
                    index += 1
                else:
                    ruleString += rule

            self.table.setItem(currentRow, 0, QTableWidgetItem(key))
            self.table.setItem(currentRow, 1, QTableWidgetItem(ruleString))
            currentRow += 1

        #detectionHistory = recorder.readDetectionHistory()


    def createMiningProcessTable(self, detectionHistory):
        self.miningProTable.setRowCount(0)
        historyLen = len(detectionHistory)
        print(f"historyLen {historyLen}")
        print(f"detectionHistory {detectionHistory}")
        btn = None


        self.miningProTable.setRowCount(historyLen + 1)
        self.miningProTable.setColumnCount(3)
        self.miningProTable.verticalHeader().setVisible(False)
        self.miningProTable.horizontalHeader().setVisible(False)

        self.miningProTable.setItem(0, 0, QTableWidgetItem("Process"))
        self.miningProTable.setItem(0, 1, QTableWidgetItem("Total Rules Met"))
        self.miningProTable.setItem(0, 2, QTableWidgetItem("Kill Associated Processes?"))


        currentRow = 1
        dictionaryIndex = 0
        keys = list(detectionHistory.keys())

        while dictionaryIndex != historyLen:
            ruleCountString = ''
            key = keys[dictionaryIndex]
            print(f"while key: {key}")
            ruleLen = len(detectionHistory[key])
            dictionaryIndex +=1
            index = 1

            for dict in detectionHistory[key]:
                    ruleCountString += dict + ": " + str(detectionHistory[key][dict]) + "x\n"
            #btn = QPushButton(key)
            #self.killBtn = QPushButton(key)

            self.miningProTable.setItem(currentRow, 0, QTableWidgetItem(key))
            self.miningProTable.setItem(currentRow, 1, QTableWidgetItem(ruleCountString))
            self.miningProTable.setRowHeight(currentRow, 120)
            #self.miningProTable.setCellWidget(currentRow, 2, self.killBtn)
            # FIX BUTTON STUFF
            currentRow += 1

        self.miningProTable.setColumnWidth(1, 350)
        self.miningProTable.setRowHeight(1, 120)
        self.miningProTable.setColumnWidth(2, 400)






    def plotDetectionGraph(self, detectionHistory):
        processesList = list(detectionHistory.keys())
        CPUPercentageCheckData = []
        MemoryUsageCheckData = []

        for proc in detectionHistory:
            try:
                CPUPercentageCheckData.append(detectionHistory[proc]["CPUPercentageCheck"])
            except:
                CPUPercentageCheckData.append(0)
            try:
                MemoryUsageCheckData.append(detectionHistory[proc]["MemoryUsageCheck"])
            except:
                MemoryUsageCheckData.append(0)

        xAxis = numpy.arange(len(CPUPercentageCheckData))
        barWidth = 0.2

        self.figure.clear()

        ax = self.figure.add_subplot(111)
        self.figure.tight_layout()
        ax.grid(axis='y')

        #print(f"CPUPercentageCheckData: {CPUPercentageCheckData}")
        #print(f"MemoryUsageCheckData: {MemoryUsageCheckData}")
        ax.bar(xAxis, CPUPercentageCheckData, width = barWidth, label="CPUPercentageCheck")
        ax.bar(xAxis + barWidth, MemoryUsageCheckData, width = barWidth, label="MemoryUsageCheck")

        ax.set_xticks(xAxis + barWidth*0.5)
        ax.set_xticklabels(processesList)
        ax.set_title("Supicious Processes")
        ax.set_xlabel("Processes")
        ax.set_ylabel("Number of detections")

        ax.legend()

        self.canvas.draw()

class NavigationToolbar(NavigationToolbar2QT):
    toolitems = [t for t in NavigationToolbar2QT.toolitems if t[0] in ('Home', 'Save')]



if __name__ == '__main__':
    gui = GUI2()
    gui.mainGUI()
