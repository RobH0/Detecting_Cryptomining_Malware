import psutil
import os
import dns.resolver
import time
import pickle


class SystemMonitoring:
    """Responsible for generating monitoring data that is later evaluated against detection rules."""

    def __init__(self):
        """SystemMonitoring constructure."""
        processCPUData = []
        processMemoryData = []
        allProcessesMonitoringData = {}
        allProcMem = {}
        self.wl = Whitelist()
        self.whitelistData = self.wl.readWhitelist()

    def monitorCpuUsage(self, intervalTime):
        """
        Monitors the CPU utilisation of all running processes on a computer.

        :param intervalTime: Defines the time in seconds there should be between each cpu utilisation calculation.
        :type intervalTime: float

        :return: A dicitonary whose key are the processes running on the computer and the corresponding value is the cpu utilisation of that process.
        :rtype: dict
        """
        self.allProcessesMonitoringData = {}
        self.whitelistData = self.wl.readWhitelist()

        try:
            for pro in psutil.process_iter():
                self.processCPUData = ["CPU"]
                temp = (pro.name(), pro.cpu_percent(interval=intervalTime))

                if temp[1] != 0 and temp[0].lower() not in self.whitelistData:
                    self.processCPUData.append(temp[1])
                    self.allProcessesMonitoringData[temp[0]] = self.processCPUData

            print("\nCPU monitoring data: ", end='')
            print(self.allProcessesMonitoringData)
            return self.allProcessesMonitoringData

        except:
            print("CPU utilisation monitoring isn't functioning properly.")

    def monitorMemoryUsage(self):
        """
        Monitors the memory utilisation of all running processes on a computer.

        :return: A dicitonary whose key are the processes running on the computer and the corresponding value is the memory utilisation of that process.
        :rtype: dict
        """

        self.allProcMem = {}

        try:
            for pro in psutil.process_iter():
                self.processMemoryData = ["Mem"]
                temp = (pro.name(), pro.memory_percent())

                if temp[1] > 1 and temp[0].lower() not in self.whitelistData:
                    self.processMemoryData.append(temp[1])
                    self.allProcMem[temp[0]] = self.processMemoryData

            print("Memory monitoring data: ", end='')
            print(self.allProcMem)
            return self.allProcMem

        except:
            print("Memory utilisation monitoring isn't functioning properly")

    def monitorConnection(self):
        """
        Monitors all established TCP connections on a computer

        :return: A list of tuples representing all TCP connections.
        :rtype: list
        """
        self.connectionData = None

        try:
            self.connectionData = psutil.net_connections("tcp")

            return self.connectionData
        except:
            print("Monitoring TCP connections didn't work!")

    def getMiningPoolIPs(self):
        """
        DNS queries mining pool domains for their corresponding IP addresses.

        :return: A list of mining pool IP addresses.
        :rtype: list
        """
        minerIPs = []

        miningPoolDomains = ['pool.minerxmr.com', 'pool.hashvault.pro',
                             'pool.supportxmr.com', 'xmr.pool.minergate.com', 'xmr.eu1.nanopool.org',
                             'xmr-eu2.nanopool.org', 'xmr-us-east1.nanopool.org', 'xmr-us-west1.nanopool.org',
                             'xmr-asia1.nanopool.org', 'xmr-jp1.nanopool.org', 'xmr-au1.nanopool.org', 'xmrpool.eu']

        for pool in miningPoolDomains:
            try:
                queryOutput = dns.resolver.query('pool.minexmr.com', 'A')
                for data in queryOutput:
                    minerIPs.append(str(data))
                print(f"IPs found for {pool}")
            except:
                print(f"DNS query for {pool} wasn't possible!")

        poolIPFile = open("poolIPs.pkl", "wb")
        pickle.dump(minerIPs, poolIPFile)
        poolIPFile.close()

        return minerIPs


class Whitelist:
    """This class provides the ability to read and open the whitelist file."""

    def __init__(self):
        """Constructure"""
        self.whitelist = []

    def readWhitelist(self):
        """
        Reads the whitelist.txt file.

        :return: a list containing all processes found in the whitelist file.
        :rtype: list
        """
        whitelistFile = open("processWhitelist.txt", "r")
        with open("processWhitelist.txt", "r") as whitelistFile:
            self.whitelist = [line.strip() for line in whitelistFile]

        return self.whitelist

    def manuallyModify(self):
        """
        Opens the whitelist file with notepad.
        """
        os.startfile('processWhitelist.txt')
