import yaml
from rules import *
import sys
from inspect import signature
import psutil
from generalMonitoring import Whitelist


class DefineAndCall:
    """This class is responsible for ensuring the correct rules are called based on the configuration file."""

    def determineRelevantRule(self, monitoringData, configuration):
        """
        Determines which rule should be called based on comparing the contents of the configuration file and the type of monitoring data.

        :param monitoringData: The monitoring data to be compared with certain detection rules.
        :type monitoringData: dict
        :param configuration: A dictionary where each key is the type of monitoring data and the corresponding value is a list of the rules that the monitoring data should be compared against.
        :param configuration: dict

        :return: A dictionary containing all the processes and the detection rules they met.
        :rtype: dict
        """

        typeData = configuration.get("data")
        cpuRules = configuration.get("CPU")
        memRules = configuration.get("Mem")
        rulesMet = []
        self.rulesMetDict = {}
        returnedValue = None
        wl = Whitelist()
        self.whitelist = wl.readWhitelist()

        # check if monitoring data is of type list since tcp connection monitoring data
        # is the only monitoring data that is passed as a list.
        if type(monitoringData) is list:
            connectionDataDict = {}
            monDataType = 'Connections'
            # first converts the relevant at components of the connection monitoring data
            # into a dictionary.
            for index in monitoringData:
                try:
                    IP = str(index[4][0])
                    currentPid = str(index[6])
                    currentPid = int(currentPid)

                    if psutil.pid_exists(currentPid):
                        for proc in psutil.process_iter():
                            if proc.pid == currentPid:
                                procName = proc.name()
                                if procName not in connectionDataDict.keys():
                                    connectionDataDict[procName] = [
                                        IP]
                                else:
                                    connectionDataDict[procName].append(
                                        IP)
                except Exception as e:
                    pass

            # calls the correct rules for connection monitoring data based on the configuration.yaml file.
            for monKey in connectionDataDict:
                if monKey.lower() not in self.whitelist:
                    for key, value in configuration.items():
                        if key == monDataType:
                            for rule in value:
                                classToCall = getattr(
                                    sys.modules[__name__], rule)
                                methodToCall = getattr(
                                    classToCall, 'check')
                                functionArgs = list(
                                    signature(methodToCall).parameters.keys())

                                for IP in connectionDataDict[monKey]:
                                    tempReturnedValue = methodToCall(
                                        IP)
                                    if tempReturnedValue == True:
                                        returnedValue = True

                            if(returnedValue == True):
                                if monKey in self.rulesMetDict:
                                    self.rulesMetDict[monKey].append(
                                        rule)
                                else:
                                    self.rulesMetDict[monKey] = [rule]

                                print(
                                    monKey + ': [' + rule + " returnedValue: " + str(returnedValue)+']')
                else:
                    pass

            return self.rulesMetDict

        else:
            # calls instance of rules determined by parameter set by configuration file.
            try:
                for monKey in monitoringData:
                    monDataType = monitoringData.get(monKey)[0]
                    monDataValues = monitoringData.get(monKey)

                    for key, value in configuration.items():
                        if key == monDataType:
                            for rule in value:
                                classToCall = getattr(
                                    sys.modules[__name__], rule)
                                methodToCall = getattr(
                                    classToCall, 'check')
                                functionArgs = list(
                                    signature(methodToCall).parameters.keys())

                                if "process" in functionArgs:
                                    returnedValue = methodToCall(
                                        monKey)
                                else:
                                    returnedValue = methodToCall(
                                        monDataValues)

                                if(returnedValue == True):
                                    if monKey in self.rulesMetDict:
                                        self.rulesMetDict[monKey].append(
                                            rule)
                                    else:
                                        self.rulesMetDict[monKey] = [
                                            rule]

                                    print(
                                        monKey + ': [' + rule + " returnedValue: " + str(returnedValue)+']')
                return self.rulesMetDict
            except Exception as e:
                return self.rulesMetDict

    def readRuleConfiguration(self, configurationFile):
        """
        Reads the configuration.yaml file and returns its contents so that the contents can be later used to determine which rule should be called.

        :param configurationFile: A string of the name of the configuration file.
        :type configurationFile: str

        :return: A dictionary whose keys are the types of monitoring data and the corresponding value is a list of the rules that should be called for that type of monitoring data.
        :rtype: dictionary
        """

        configFile = open(configurationFile, "r")
        configurationList = yaml.load(configFile, Loader=yaml.FullLoader)
        return configurationList
